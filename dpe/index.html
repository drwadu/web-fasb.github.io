<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/posts.css">
    <link rel="stylesheet" href="css/clingo.css">
</head>
<body>

  <main class="page-content" aria-label="Content">
    <div class="wrapper">
      <article class="post">

        <header class="post-header">
	  <center>
	  <h1 class="title"><a href="https://github.com/drwadu/fasb" title="fasb repo">fasb</a> web application</h1>
	  </center>
        </header>

        <div class="post-content">
          <div class="center">
            <pre id="input">
% specifies that we expect exactly one first and one second digit as input
1 {f_00;f_01;f_02; f_03;f_04;f_05; f_06;f_07;f_08;f_09} 1. 
1 {f_10;f_11;f_12; f_13;f_14;f_15; f_16;f_17;f_18;f_19} 1.

%* 
rules are retrieved from Table 7 on page 24 in 
https://proceedings.mlr.press/v202/barbiero23a/barbiero23a.pdf
*%
y_0  :- f_00, f_10. y_1  :- f_00, f_11. y_1  :- f_01, f_10. y_2  :- f_00, f_12. 
y_2  :- f_01, f_11. y_2  :- f_02, f_10. y_3  :- f_01, f_12. y_3  :- f_03, f_10.
y_3  :- f_02, f_11. y_3  :- f_00, f_13. y_4  :- f_03, f_11. y_4  :- f_04, f_10. 
y_4  :- f_01, f_13. y_4  :- f_02, f_12. y_4  :- f_00, f_14. y_5  :- f_01, f_14.
y_5  :- f_03, f_12. y_5  :- f_04, f_11. y_5  :- f_00, f_15. y_5  :- f_02, f_13.
y_5  :- f_05, f_10. y_6  :- f_02, f_14. y_6  :- f_05, f_11. y_6  :- f_00, f_16. 
y_6  :- f_04, f_12. y_6  :- f_01, f_15. y_6  :- f_03, f_13. y_6  :- f_06, f_10.
y_7  :- f_00, f_17. y_7  :- f_04, f_13. y_7  :- f_01, f_16. y_7  :- f_02, f_15. 
y_7  :- f_07, f_10. y_7  :- f_06, f_11. y_7  :- f_05, f_12. y_7  :- f_03, f_14. 
y_8  :- f_05, f_13. y_8  :- f_01, f_17. y_8  :- f_03, f_15. y_8  :- f_02, f_16.
y_8  :- f_06, f_12. y_8  :- f_08, f_10. y_8  :- f_07, f_11. y_8  :- f_04, f_14.
y_8  :- f_00, f_18. y_8  :- f_03, f_16. y_9  :- f_04, f_15. y_9  :- f_08, f_11. 
y_9  :- f_06, f_13. y_9  :- f_01, f_18. y_9  :- f_00, f_19. y_9  :- f_03, f_16. 
y_9  :- f_09, f_10. y_9  :- f_07, f_12. y_9  :- f_02, f_17. y_9  :- f_05, f_14. 
y_10 :- f_01, f_19. y_10 :- f_06, f_14. y_10 :- f_09, f_11. y_10 :- f_08, f_12.
y_10 :- f_07, f_13. y_10 :- f_04, f_16. y_10 :- f_03, f_17. y_10 :- f_02, f_18. 
y_10 :- f_05, f_15. y_11 :- f_08, f_13. y_11 :- f_03, f_18. y_11 :- f_07, f_14. 
y_11 :- f_09, f_12. y_11 :- f_04, f_17. y_11 :- f_05, f_16. y_11 :- f_02, f_19.
y_11 :- f_06, f_15. y_12 :- f_03, f_19. y_12 :- f_04, f_18. y_12 :- f_06, f_16. 
y_12 :- f_07, f_15. y_12 :- f_09, f_13. y_12 :- f_05, f_17. y_12 :- f_08, f_14. 
y_13 :- f_06, f_17. y_13 :- f_08, f_15. y_13 :- f_09, f_14. y_13 :- f_07, f_16.
y_13 :- f_05, f_18. y_13 :- f_04, f_19. y_14 :- f_06, f_18. y_14 :- f_07, f_17. 
y_14 :- f_05, f_19. y_14 :- f_09, f_15. y_14 :- f_08, f_16. y_15 :- f_09, f_16. 
y_15 :- f_08, f_17. y_15 :- f_07, f_18. y_15 :- f_06, f_19. y_16 :- f_07, f_19.
y_16 :- f_09, f_17. y_16 :- f_08, f_18. y_17 :- f_09, f_18. y_17 :- f_08, f_19. 
y_18 :- f_09, f_19.
</pre>
            <pre id="cnf">
y_8
f_03 f_16</pre>
            <ul class="hlist">
              <li>
                <select id="mode">
                  <option selected>answer sets</option>
                  <option>facet-inducing atoms</option>
                  <option>significances</option>
                  <option>conditional probabilities</option>
                </select>
              </li>
            <input type="button" id="run" value="enter" onclick="solve()"/>
            </ul>
            <pre id="output" class="code"> </pre>
          </div>
        </div>
      </article>
    </div>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/clingo-wasm@0.1.1"></script>
  <script type="text/javascript" src="js/ace.js" charset="utf-8"></script>

  <script>
    var outputElement = document.getElementById('output');
    var input = ace.edit("input");
    var cnf = ace.edit("cnf");
    var ex = document.getElementById("examples");
    var output = "- input an encoding\n- input a cnf: one clause per line with whitespace seperated literals (use `~` for negation)\n- choose an option in the drop-down list\n- press the enter button";

    cnf.$blockScrolling = Infinity;
    cnf.setOptions({
        showGutter: false,
        useSoftTabs: true,
        tabSize: 2,
        maxLines: Infinity,
        autoScrollEditorIntoView: true,
        showPrintMargin: false,
    });
    input.$blockScrolling = Infinity;
    input.setOptions({
        useSoftTabs: true,
        tabSize: 2,
        maxLines: Infinity,
        mode: "ace/mode/gringo",
        autoScrollEditorIntoView: true,
        showPrintMargin: false,
    });

    outputElement.textContent = output;

    async function main() {
        await clingo.init("https://cdn.jsdelivr.net/npm/clingo-wasm@0.1.1/dist/clingo.wasm");
    }

    main();

    async function solve() {
        var index = document.getElementById("mode").selectedIndex;

        if (index == 0) {
            answer_sets();
        } else if (index == 1) {
            facet_inducing_atoms();
        } else if (index == 2) {
            uncertainty_reductions();
	} else {
	    conditional_probabilities();
	}
    }

    async function answer_sets() {
        outputElement.textContent = "";

        delta = cnf.getValue().split("\n").filter(x => x.length > 0).map(x => ":- " + x.trim().split(" ").map((l) => {
            if (l.charAt(0) == '~') {
                return l.substring(1)
            } else {
                return "not " + l
            }
        }).join(",") + ".").join("\n");

        let lp = input.getValue() + "\n" + delta;

        output = "collecting answer sets...";
        outputElement.textContent = output;

        let res = await clingo.run(lp, 0);

        xs = res.Call[0].Witnesses;

        outputElement.textContent = "";
        for (let i = 0; i < xs.length; i++) {
            const x = xs[i].Value;

            outputElement.textContent += "solution " + (i + 1) + ":\n";
            for (let j = 0; j < x.length; j++) {
                outputElement.textContent += x[j] + " ";
            }
            outputElement.textContent += "\n";
        }
    }

    async function facet_inducing_atoms() {
        outputElement.textContent = "";

        delta = cnf.getValue().split("\n").filter(x => x.length > 0).map(x => ":- " + x.trim().split(" ").map((l) => {
            if (l.charAt(0) == '~') {
                return l.substring(1)
            } else {
                return "not " + l
            }
        }).join(",") + ".").join("\n");

        let lp = input.getValue() + "\n" + delta;

        let res = await clingo.run(lp, 0, ["--enum-mode=brave", "--opt-strategy=usc"]);
        bcs = res.Call[0].Witnesses.slice(-1)[0].Value;

        if (bcs.length == 0) {
            outputElement.textContent = "unsat program, no facets";
            return;
        }

        res = await clingo.run(lp, 0, ["--enum-mode=cautious", "--opt-strategy=usc"]);
        let ccs = new Set(res.Call[0].Witnesses.slice(-1)[0].Value);

        let fcs = bcs.filter(x => !ccs.has(x));
        facets = fcs;

        count = fcs.length;
        outputElement.textContent += "count: " + count + "\n";
        for (let i = 0; i < fcs.length; i++) {
            const atom = fcs[i];
            outputElement.textContent += "\n" + atom;
        }
    }

    async function uncertainty_reductions() {
        outputElement.textContent = "";

        delta = cnf.getValue().split("\n").filter(x => x.length > 0).map(x => ":- " + x.trim().split(" ").map((l) => {
            if (l.charAt(0) == '~') {
                return l.substring(1)
            } else {
                return "not " + l
            }
        }).join(",") + ".").join("\n");

        let lp = input.getValue() + "\n" + delta;


        let res = await clingo.run(lp, 0, ["--enum-mode=brave", "--opt-strategy=usc"]);
        bcs = res.Call[0].Witnesses.slice(-1)[0].Value;

        if (bcs.length == 0) {
            return;
        }

        res = await clingo.run(lp, 0, ["--enum-mode=cautious", "--opt-strategy=usc"]);
        let ccs = new Set(res.Call[0].Witnesses.slice(-1)[0].Value);

        let fcs = bcs.filter(x => !ccs.has(x));
        facets = fcs;

        count = 2 * fcs.length;
        outputElement.textContent = "found " + count + " facets\n\n";
        outputElement.textContent += " inc    exc   \n";
        for (let i = 0; i < fcs.length; i++) {
            const atom = fcs[i];

            let fcs_ = [];

            p = lp + "\n:- not " + atom + ".";
            let n = 0;
            res = await clingo.run(p, 0, ["--enum-mode=brave", "--opt-strategy=usc"]);
            bcs = res.Call[0].Witnesses.slice(-1)[0].Value;
            if (bcs.length == 0) {
                fcinc = 0;
            }
            res = await clingo.run(p, 0, ["--enum-mode=cautious", "--opt-strategy=usc"]);
            let ccs = new Set(res.Call[0].Witnesses.slice(-1)[0].Value);
            fcs_ = bcs.filter(x => !ccs.has(x));
            n = 2 * fcs_.length;
            outputElement.textContent += ((count - n) / count).toFixed(3) + "  ";

            p = lp + "\n:- " + atom + ".";
            res = await clingo.run(p, 0, ["--enum-mode=brave", "--opt-strategy=usc"]);
            bcs = res.Call[0].Witnesses.slice(-1)[0].Value;
            if (bcs.length == 0) {
                fcinc = 0;
            }
            res = await clingo.run(p, 0, ["--enum-mode=cautious", "--opt-strategy=usc"]);
            ccs = new Set(res.Call[0].Witnesses.slice(-1)[0].Value);
            fcs_ = bcs.filter(x => !ccs.has(x));
            n = 2 * fcs_.length;
            outputElement.textContent += ((count - n) / count).toFixed(3) + "  " + atom + "\n";
        }
    }

    async function conditional_probabilities() {
        outputElement.textContent = "";

        delta = cnf.getValue().split("\n").filter(x => x.length > 0).map(x => ":- " + x.trim().split(" ").map((l) => {
            if (l.charAt(0) == '~') {
                return l.substring(1)
            } else {
                return "not " + l
            }
        }).join(",") + ".").join("\n");

        let lp = input.getValue() + "\n" + delta;

        let res = await clingo.run(lp, 0, ["--enum-mode=brave", "--opt-strategy=usc"]);
        bcs = res.Call[0].Witnesses.slice(-1)[0].Value;

        if (bcs.length == 0) {
            return;
        }

        res = await clingo.run(lp, 0, ["--enum-mode=cautious", "--opt-strategy=usc"]);
        let ccs = new Set(res.Call[0].Witnesses.slice(-1)[0].Value);

        let fcs = bcs.filter(x => !ccs.has(x));
        facets = fcs;

        res = await clingo.run(lp, 0);
        count = res.Models.Number;

        outputElement.textContent = "found " + count + " answer sets in total\n\n";
        outputElement.textContent += " inc    exc   \n";
        for (let i = 0; i < fcs.length; i++) {
            const atom = fcs[i];

            p = lp + "\n:- not " + atom + ".";
            let n = 0;
            res = await clingo.run(p, 0);
            n = res.Models.Number;
            outputElement.textContent += (1.0-((count - n) / count)).toFixed(3) + "  ";

            p = lp + "\n:- " + atom + ".";
            res = await clingo.run(p, 0);
            n = res.Models.Number;
            outputElement.textContent += (1.0-((count - n) / count)).toFixed(3) + "  " + atom + "\n";
        }
    }

    async function representative_answer_sets() {
        outputElement.textContent = "";

        delta = cnf.getValue().split("\n").filter(x => x.length > 0).map(x => ":- " + x.trim().split(" ").map((l) => {
            if (l.charAt(0) == '~') {
                return l.substring(1)
            } else {
                return "not " + l
            }
        }).join(",") + ".").join("\n");

        let lp = input.getValue() + "\n" + delta;

        outputElement.textContent = "...\n";
        let res = await clingo.run(lp, 0, ["--enum-mode=brave", "--opt-strategy=usc"]);
        bcs = res.Call[0].Witnesses.slice(-1)[0].Value;
        if (bcs.length == 0) {
            return;
        }
        res = await clingo.run(lp, 0, ["--enum-mode=cautious", "--opt-strategy=usc"]);
        let ccs = new Set(res.Call[0].Witnesses.slice(-1)[0].Value);
        let fcs = bcs.filter(x => !ccs.has(x));
        to_observe = fcs;
        let prev = to_observe.length;
        let curr = prev;

        let n = 1;
        for (let i = 0; i < fcs.length; i++) {
            if (prev == 0) { 
                return; 
            }

            const atom = fcs[i];
            res = await clingo.run(lp + ":- not " + atom + ".", 1);
            xs = new Set(res.Call[0].Witnesses.slice(-1)[0].Value);
            to_observe = to_observe.filter(x => !xs.has(x));
            curr = to_observe.length;

            xs = Array.from(xs);
            if (prev > curr) {
                outputElement.textContent += "solution " + n + ":\n";
                for (let k = 0; k < xs.length; k++) { outputElement.textContent += xs[k] + " "; }
                outputElement.textContent += "\n";
                n += 1;
            }

            prev = curr;
        }
    }
  </script>

</body>

</html>
